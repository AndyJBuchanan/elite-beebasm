\************************************************
\* Source Code for ELITE  (the loader)
\************************************************

DISC=TRUE
PROT=FALSE
HIMEM=&4000
;DIMTEMP%256
LOD%=&1100

C%=&F40
S%=C%
L%=LOD%+&28
D%=&563A
LC%=&6000-C%

svn=&7FFD
len1=15
len2=18
len=len1+len2

LE%=&B00

;REM  Move Mover to here while CODE loading

IF DISC
LL%=&E00+&300
ELSE
LL%=&E00
ENDIF

;CODE=&4000
CODE=LL%        ; we can assemble in place

;REM Where this loader loads

MOS=S%+8
TRTB%=4
NETV=&224

OSWRCH=&FFEE
OSBYTE=&FFF4
OSWORD=&FFF1
SCLI=&FFF7
IRQ1V=&204
osprnt=&234

ZP=&70
P=&72
Q=&73
YY=&74
T=&75
sc=&76
BLPTR=&78
V219=&7A
K3=&80
BLCNT=&81
BLN=&83
EXCN=&85

FF=&FF

VIA=&FE40
USVIA=VIA
VSCAN=57-1
VEC=&7FFE

;OSCLI("L.:0.WORDS9 "+STR$~CODE)
ORG CODE
PRINT "WORDS9=",~P%
INCBIN "data/WORDS9.bin"

;OSCLI("L.:0.DIALSHP "+STR$~(CODE+&400))
ORG CODE+&400
PRINT "DIALSHP=",~P%
INCBIN "data/DIALSHP.bin"

;OSCLI("L.:2.P.ELITE "+STR$~(CODE+&C00))
ORG CODE+&C00
PRINT "P.ELITE=",~P%
INCBIN "data/P.ELITE.bin"

;OSCLI("L.:2.P.A-SOFT "+STR$~(CODE+&D00))
ORG CODE+&D00
PRINT "P.A-SOFT=",~P%
INCBIN "data/P.A-SOFT.bin"

;OSCLI("L.:2.P.(C)ASFT "+STR$~(CODE+&E00))
ORG CODE+&E00
PRINT "P.(C)ASFT=",~P%
INCBIN "data/P.(C)ASFT.bin"

;REMOSCLI("L.:2.P.NAME$ "+STR$~(CODE+&E00))

ORG LL%+&400+&800+&300
O%=CODE+&400+&800+&300

.run JMPENTRY

B%=P%
N%=67       ; DATA 67:READ N%

EQUB 22,4,28,2,17,15,16
EQUB 23,0, 6,31,0,0,0,0,0,0
EQUB 23,0,12,12,0,0,0,0,0,0
EQUB 23,0,13, 0,0,0,0,0,0,0
EQUB 23,0, 1,32,0,0,0,0,0,0
EQUB 23,0, 2,45,0,0,0,0,0,0
EQUB 23,0,10,32,0,0,0,0,0,0

E%=P%

EQUB 1,1,0,111,-8,4,1,8, 8,-2,0,-1,112,44
EQUB 2,1,14,-18,-1,44,32,50, 6,1,0,-2,120,126
EQUB 3,1,1,-1,-3,17,32,128,1,0,0,-1,1,1
EQUB 4,1,4,-8,44,4,6,8,22,0,0,-127,126,0

MACRO FNE I%
LDX#((E%+I%*14)MOD256)
LDY#((E%+I%*14)DIV256)
LDA#8
JSROSWORD
ENDMACRO

.swine LDA#&7F
STA&FE4E
JMP(&FFFC)

\ This bit runs where it loads

.OSB LDY#0
JMPOSBYTE
EQUS"R.ELITEcode"
EQUB13
EQUS"By D.Braben/I.Bell"
EQUB13
EQUB&B0
.oscliv EQUW&FFF7
.David9 EQUW David5
CLD
.David23 EQUW (512-len)

.doPROT1 LDY#&DB
STYTRTB%
LDY#&EF \0.1 look-up keys
STYTRTB%+1
LDY#2
STYV219+1
STAPROT1-255,X
LDY#&18
STYV219+1,X
RTS
.MHCA EQUB&CA
.David7 BCCIan1

.ENTRY SEI
CLD

IF DISC=FALSE
LDA#0
LDX#FF
JSROSBYTE
TXA
BEQOS100
LDY&FFB6
LDA&FFB7
STAZP
LDA&FFB8
STAZP+1
DEY
.ABCDEFG LDA(ZP),Y
STA&200,Y
DEY
BPLABCDEFG
.OS100
ENDIF

LDA#&7F
STA&FE4E
STA&FE6E
LDA&FFFC
STA&200
STA&202
STA&206
STA&220
LDA&FFFD
STA&201
STA&203
STA&207
STA&221 \ Cold reset (Power on) on BRK,USER,& unrecog IRQ


LDX#&2F-2
.purge LDA&202,X
ORA#&C0
STA&202,X
DEX
DEX
BPLpurge


LDA#&60
STA&232
LDA#2
STANETV+1
LDA#&32
STANETV \Knock out NETVEC


LDA#32
EQUB&2C
.Ian1 BNEDavid3
STADavid2
LSRA
LDX#3
STXBLPTR+1
STXBLN+1
STXEXCN+1
DEX
JSROSBYTE \ADC


EQUB&2C
.FRED1 BNEDavid7


LDX#255
LDA#&48
JSRdoPROT1
LDA#144
JSROSB \TV


LDA#247
LDX#0
JSROSB \BREAK vec


\LDA#&81\LDY#FF\LDX#1\JSROSBYTE\TXA\BPLOS01 \Damn 0.1


LDA#190
LDX#8
JSROSB \8bitADC


EQUB&2C
.David8 BNEFRED1


LDA#&8F
LDX#&C
LDY#FF
JSROSBYTE \ claim NMIs


LDA#13
.abrk LDX#0
JSROSB \otput bffer


LDA#225
LDX#128
JSROSB \fn keys


LDA#172
LDX#0
LDY#255
JSROSBYTE
STXTRTB%
STYTRTB%+1 \int-ascii table


LDA#200
LDX#3
JSROSB

IF PROT AND DISC=0
CPX#3
BNEabrk+1 \Clear memory on BREAK 
ENDIF

LDA#13
LDX#2
JSROSB \kybrd buffer

.OS01
LDX#FF
TXS
INX
.David3 LDABEGIN%,X
.PROT1 INY \PHA
INX
CPX#len
BNEDavid8 \^stack

LDA#(B% MOD256)
STAZP
LDA#&C8
STAPROT1
LDA#(B% DIV256)
STAZP+1
LDY#0
.LOOP LDA(ZP),Y
JSROSWRCH
INY
CPY#N%
BNELOOP \set up pokey-mode-4

LDA#1
TAX
TAY
STA(V219),Y
LDA#4
JSROSB \cursor

LDA#9
LDX#0
JSROSB \flashing

LDA#&6C
EORcrunchit
STAcrunchit

FNE 0
FNE 1
FNE 2
FNE 3 \envelopes

LDX#4
STXP+1
LDA#(LL%DIV256)
STAZP+1
LDY#0
LDA#256-len1
STA(V219-4,X)
STYZP
STYP
JSRcrunchit \Move WORDS9 to &400

LDX#1
LDA#((LL%DIV256)+&C)
STAZP+1
LDA#&63
STAP+1
LDY#0
JSRcrunchit
LDX#1
LDA#((LL%DIV256)+&D)
STAZP+1
LDA#&61
STAP+1
LDY#0
JSRcrunchit
LDX#1
LDA#((LL%DIV256)+&E)
STAZP+1
LDA#&76
STAP+1
LDY#0
JSRcrunchit

JSRPLL1 \draw Saturn

LDX#8
LDA#((LL%DIV256)+4)
STAZP+1
LDA#&78
STAP+1
LDY#0
STYZP
STYBLCNT
STYP
JSRcrunchit \Move DIALSHP to &7800

LDX#(3-(DISC AND1))
LDA#(UU%DIV256)
STAZP+1
LDA#(UU%MOD256)
STAZP
LDA#(LE%DIV256)
STAP+1
LDY#0
STYP
JSRcrunchit \Move Part of this program to LE%

STYDavid3-2
\LDY#0
.David2 EQUB&AC
EQUW&FFD4 \JSR&FFD4
.LBLa LDAC%,X
EOR#&A5
STAC%,X
DEX
BNELBLa
JMP(C%+&CF)
.swine2 jmpswine
EQUW&4CFF
.crunchit BRK
EQUW David23
.RAND EQUD &6C785349
.David5 INY
CPY#(ENDBLOCK-BLOCK)
BNEDavid2

SEI
LDA#&C2
STAVIA+&E
LDA#&7F
STA&FE6E
LDAIRQ1V
STAVEC
LDAIRQ1V+1
BPLswine2
STAVEC+1
LDA#(IRQ1 DIV256)
STAIRQ1V+1
LDA#(IRQ1 MOD256)
STAIRQ1V
LDA#VSCAN
STAUSVIA+5
CLI \ INTERRUPTS NOW OK


IF DISC
LDA#&81
STA&FE4E
LDY#20
JSROSBYTE
LDA#1
STA&FE4E
ENDIF

RTS  \ENTRY2 on stack already

.PLL1 LDAVIA+4
STARAND+1
JSRDORND
JSRSQUA2
STAZP+1
LDAP
STAZP
JSRDORND
STAYY
JSRSQUA2
TAX
LDAP
ADCZP
STAZP
TXA
ADCZP+1
BCSPLC1

STAZP+1
LDA#1
SBCZP
STAZP
LDA#&40
SBCZP+1
STAZP+1
BCCPLC1
JSRROOT
LDAZP
LSRA
TAX
LDAYY
CMP#128
RORA
JSRPIX

.PLC1 DECCNT
BNEPLL1
DECCNT+1
BNEPLL1
LDX#&C2
STXEXCN

.PLL2 JSRDORND
TAX
JSRSQUA2
STAZP+1
JSRDORND
STAYY
JSRSQUA2
ADCZP+1
CMP#&11
BCCPLC2
LDAYY
JSRPIX

.PLC2 DECCNT2
BNEPLL2
DECCNT2+1
BNEPLL2
LDXMHCA
STXBLPTR
LDX#&C6
STXBLN

.PLL3 JSRDORND
STAZP
JSRSQUA2
STAZP+1
JSRDORND
STAYY
JSRSQUA2
STAT

ADCZP+1
STAZP+1
LDAZP
CMP#128
RORA
CMP#128
RORA
ADCYY
TAX
JSRSQUA2
TAY
ADCZP+1

BCSPLC3
CMP#&50
BCSPLC3
CMP#&20
BCCPLC3
TYA
ADCT
CMP#&10
BCSPL1
LDAZP
BPLPLC3
.PL1 LDAYY
JSRPIX

.PLC3 DECCNT3
BNEPLL3
DECCNT3+1
BNEPLL3

.DORND LDARAND+1
TAX
ADCRAND+3
STARAND+1
STXRAND+3
LDARAND
TAX
ADCRAND+2
STARAND
STXRAND+2
RTS

.SQUA2 BPLSQUA
EOR#FF
CLC
ADC#1

.SQUA STAQ
STAP
LDA#0
LDY#8
LSRP
.SQL1 BCCSQ1
CLC
ADCQ
.SQ1 RORA
RORP
DEY
BNESQL1
RTS

.PIX TAY
EOR#128
LSRA
LSRA
LSRA
ORA#&60
STAZP+1
TXA
EOR#128
AND#&F8
STAZP
TYA
AND#7
TAY
TXA
AND#7
TAX

LDATWOS,X
ORA(ZP),Y
STA(ZP),Y
RTS

.TWOS EQUD &10204080
EQUD&01020408

.CNT EQUW&500
.CNT2 EQUW &1DD
.CNT3 EQUW &500

.ROOT LDYZP+1
LDAZP
STAQ
LDX#0
STXZP
LDA#8
STAP
.LL6 CPXZP
BCCLL7
BNELL8
CPY#&40
BCCLL7
.LL8 TYA
SBC#&40
TAY
TXA
SBCZP
TAX
.LL7 ROLZP
ASLQ
TYA
ROLA
TAY
TXA
ROLA
TAX
ASLQ
TYA
ROLA
TAY
TXA
ROLA
TAX
DECP
BNELL6
RTS

.BEGIN% EQUB(David9 DIV256)
EQUB(David9 MOD256)
EQUB&6C \JMP
EQUB(TUT DIV256)
EQUB(TUT MOD256)
EQUB&99 \STA,Y
EQUB(TUT DIV256)
EQUB(TUT MOD256)
EQUB&59 \EOR,Y
PHA
EQUB((BLOCK)DIV256)
EQUB((BLOCK)MOD256)
EQUB&B9 \LDA,Y
PLA
PLA

.DOMOVE RTS
EQUW&D0EF \BNEMVDL
DEX
EQUBZP+1
INCP+1
EQUB&E6 \INCP+1 INCZP+1
EQUW&D0F6 \BNEMVDL
DEY
EQUBP
EQUB&91 \STA(),Y
EQUB(OSB DIV256)
EQUB(OSB MOD256)
EQUB&59 \EOR
EQUBZP
EQUB&B1 \LDA(),Y        \ 18 Bytes ^ Stack

.UU%

Q%=P%-LE%
ORG LE%                 ;P%=LE%

.CHECKbyt BRK
.MAINSUM EQUB&CB
EQUB0
.FOOLV EQUW FOOL
.CHECKV EQUWLOD%+1

.block1 EQUD&A5B5E5F5
EQUD&26366676
EQUD&8494C4D4
.block2 EQUD&A0B0C0D0
EQUD&8090E0F0
EQUD&27376777 \ Colours for interrupts

.TT26\ PRINT  Please tidy this up!

STAK3
TYA
PHA
TXA
PHA

.rr LDAK3
CMP#7
BEQR5
CMP#32
BCSRR1
CMP#13
BEQRRX1
INCYC
.RRX1 LDX#7
STXXC
BNERR4

.RR1

LDX#&BF
ASLA
ASLA
BCCP%+4
LDX#&C1
ASLA
BCCP%+3
INX
STAP
STXP+1

LDAXC
CMP#20
BCCNOLF
LDA#7
STAXC
INCYC
.NOLF ASLA
ASLA
ASLA
STAZP
INCXC
LDAYC
CMP#19
BCCRR3
LDA#7
STAXC
lda#&65
stasc+1
ldy#7*8
ldx#14
stysc
lda#0
tay
.David1 sta(sc),Y
iny
cpy#14*8
bccDavid1
tay
incsc+1
dex
bplDavid1
lda#5
STAYC

bnerr
.RR3 ORA#&60
STAZP+1
LDY#7
.RRL1 LDA(P),Y
STA(ZP),Y
DEY
BPLRRL1

.RR4 PLA
TAX
PLA
TAY
LDAK3
.FOOL RTS

.R5 lda#7
jsrosprint
JMPRR4

.TUT  \EOR here onward
.osprint jmp(osprnt)
EQUB&6C
.command jmp(oscliv)
.MESS1
IF DISC
EQUS "L.ELTcode 1100"
ELSE
EQUS "L.ELITEcode F1F"
ENDIF
EQUB13 \*LOAD ELITEcode

.ENTRY2 lda&20E
staosprnt
LDA#(TT26 MOD256)
STA&20E
LDX#(MESS1 MOD256)
lda&20F
staosprnt+1
LDA#(TT26 DIV256)
LDY#(MESS1 DIV256)
STA&20F \OSWRCH for loading messages

JSRAFOOL
JSRcommand
JSR512-len+CHECKER-ENDBLOCK 
JSRAFOOL
 \ (Gratuitous JSRs)- LOAD Mcode and checksum it.

IF DISC
LDA#140
LDX#12
JSROSBYTE \*TAPE 
ENDIF

LDA#0
STAsvn

LDX#(LC% DIV256)
LDA#(L% MOD256)
STAZP
LDA#(L% DIV256)
STAZP+1
LDA#(C% MOD256)
STAP
LDA#(C% DIV256)
STAP+1
LDY#0

.ML1 TYA
EOR(ZP),Y
STA(P),Y
INY
BNEML1
INCZP+1
INCP+1
DEX
BPLML1  \Move code down (d)

LDAS%+6
STA&202
LDAS%+7
STA&203
LDAS%+2
STA&20E
LDAS%+3
STA&20F \BRK,OSWRCH     
RTS \- ON STACK 
.AFOOL JMP(FOOLV)

.M2 EQUB2
.VIA2 LDA#4
STA&FE20
LDY#11
.inlp1 LDAblock1,Y
STA&FE21
DEY
BPLinlp1
PLA
TAY
JMP(VEC)
.IRQ1
TYA
PHA

IF PROT AND DISC=0
LDY#0
LDA(BLPTR),Y
BITM2
BNEitdone
EOR#128+3
INCBLCNT
BNEZQK
DECBLCNT
.ZQK STA(BLPTR),Y
LDA#&23
CMP(BLN),Y
BEQP%+4
EOR#17
CMP(EXCN),Y
BEQitdone
DECLOD%
.itdone
ENDIF

LDAVIA+&D
BITM2
BNELINSCN
AND#64
BNEVIA2
PLA
TAY
JMP(VEC)

.LINSCN LDA#50
STAUSVIA+4
LDA#VSCAN
STAUSVIA+5
LDA#8
STA&FE20
LDY#11
.inlp2 LDAblock2,Y
STA&FE21
DEY
BPLinlp2
PLA
TAY
JMP(VEC)

.BLOCK \ Pushed onto stack for execution   
EQUW ENTRY2-1
EQUW 512-len+BLOCK-ENDBLOCK+3

LDAVIA+4
STA1
SEI
LDA#&39
STAVIA+&E
\LDA#&7F
\STA&FE6E
\LDAIRQ1V
\STAVEC
\LDAIRQ1V+1
\STAVEC+1  Already done
LDAS%+4
STAIRQ1V
LDAS%+5
STAIRQ1V+1
LDA#VSCAN
STAUSVIA+5
CLI \Interrupt vectors

\LDA#&81LDY#FFLDX#1JSROSBYTETXAEOR#FFSTAMOS \FF if MOS0.1 else 0

\BMIBLAST
LDY#0
LDA#200
LDX#3
JSROSBYTE
.BLAST \break,escape

LDA#(S% DIV256)
STAZP+1
LDA#(S% MOD256)
STAZP
LDX#&45
LDY#0
TYA
.CHK CLC
ADC(ZP),Y
INY
BNECHK
INCZP+1
DEX
BPLCHK
CMPD%-1
BEQitsOK
.nononono STAS%+1
LDA#&7F
STA&FE4E
JMP(&FFFC)
.itsOK JMP(S%)

.CHECKER LDY#0
LDX#4
STXZP+1
STYZP
TYA
.CHKq CLC
ADC(ZP),Y
INY
BNECHKq
INCZP+1
DEX
BNECHKq
CMPMAINSUM+1
BNEnononono

TYA
.CHKb CLC
ADCLOD%,Y
INY
CPY#&28
BNECHKb
CMPMAINSUM
BNEnononono

IF PROT AND DISC=0
LDABLCNT
CMP#&4F
BCCnononono
ENDIF

JMP(CHECKV)

.ENDBLOCK \ no more on to stack

.XC EQUB7
.YC EQUB6

\\ We assembled a block of code at &B00
\\ Need to copy this up to end of main code

COPYBLOCK LE%, P%, UU%

PRINT "BLOCK_offset =", ~(BLOCK - LE%) + (UU% - CODE)
PRINT "ENDBLOCK_offset =",~(ENDBLOCK - LE%) + (UU% - CODE)
PRINT "MAINSUM_offset =",~(MAINSUM - LE%) + (UU% - CODE)
PRINT "TUT_ofset =",~(TUT - LE%) + (UU% - CODE)

\\ Further processing completed by BCFS.PY script

\\ Reverse bytes between BLOCK and ENDBLOCK
\\ Count &400 bytes for checksum
\\ Count some more bytes for another checksum
\\ EOR code bytes 
\\ EOR code words
\\ EOR data block

PRINT "UU%=",~UU%," Q%=",~Q%, " OSB=",~OSB

PRINT "Memory usage: ", ~LE%, " - ",~P%
PRINT "Stack: ",len+ENDBLOCK-BLOCK

;OSCLI("S.:0.ELITE "+STR$~CODE +" "+STR$~O% +" "+STR$~run +" "+STR$~LL%)

\\ Save ELITE loader

PRINT "S. ELITE ",~CODE," ",~UU%+(P%-LE%)," ",~run," ",~LL%
SAVE "output/ELITE.unprot.bin", CODE, UU%+(P%-LE%), run, LL%
